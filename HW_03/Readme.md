## Требования к программам

- 1. Программа должна получать все параметры в качестве аргументов командной строки.
- 2. Задачи оцениваются независимо в трех группах: задачи 1-3, задачи 4-7 и задачи 8-10.
- 3. Аргументы командной строки для задач 4-10:
	- 1) с задает номер функции, используемой для сравнения значений в массиве,
	- 2) n размерность массива,
	- 3) р количество выводимых значений в массиве,
	- 4) filename имя файла, откуда надо прочитать массив.

Например, запуск

./a04.out 1 4 4 a.txt

означает, что массив длины 4 надо прочитать из файла а. txt, выводить не более 4-х элементов массива, и использовать функцию сравнения элементов 1.

- 4. Аргументы командной строки для задач 1 и 3: добавляется дополнительный первый аргумент, остальные аргументы - как в задачах 4-10:
	- 1) х дополнительный аргумент (х строка),
	- 2) с задает номер функции, используемой для сравнения значений в массиве,
	- 3) n размерность массива,
	- 4) р количество выводимых значений в массиве,
	- 5) filename имя файла, откуда надо прочитать массив.
- 5. Аргументы командной строки для задачи 2: для задания двух входных массивов используется удвоенный "комплект" аргументов из задач 4-10:
	- 1) с задает номер функции, используемой для сравнения значений в массивах,
	- 2) n размерность массива а,
	- 3) Ра количество выводимых значений в массиве а,
	- 5) filenamea имя файла, откуда надо прочитать массив а,
	- 6) m размерность массива b,
	- 7) рь количество выводимых значений в массиве b,
	- 9) filenameb имя файла, откуда надо прочитать массив b.

Например, запуск

./a02.out 1 4 4 a.txt 6 6 b.txt

означает, что массив а длины 4 надо прочитать из файла а . txt, выводить не более 4-х элементов массива, массив b длины 6 надо прочитать из файла b.txt, выводить не более 6-ти элементов массива, и использовать функцию сравнения элементов 1.

6. Ввод массива должен быть оформлен в виде подпрограммы. В указанном файле находится массив в формате:

> строка-1 строка-2 строка-п

где n - указанный размер массива. Строки разделяются символом новой строки, который сам в результирующую строку в массиве не входит. Программа должна выводить сообщение об ошибке, если указанный файл не может быть прочитан, содержит меньшее количество данных или данные неверного формата.

- 7. Задание функции сравнения элементов. В программе должны быть следующие функции сравнения элементов:
	- с = 1) лексикографически по возрастанию,
	- с = 2) лексикографически по убыванию,
	- с = 3) по возрастанию длины строки,
	- с = 4) по убыванию длины строки,

В зависимости от аргумента командной строки с в функции задач 1-10 передается указатель на соответствующую функцию. Функция сравнения элементов Х и У возвращает целое число, меньшее 0, если X меньше Y относительно принятого порядка сравнения элементов (Х < Y); большее 0, если X больше Y относительно принятого порядка сравнения элементов (X > Y); и 0 иначе (X ~ Y ).

- 8. Решение задачи должно быть оформлено в виде подпрограммы, получающей в качестве аргументов массив и его длину (в ряде задач также дополнительные аргументы). Получать в этой подпрограмме дополнительную информацию извне, а также выводить что-либо на экран, запрещается.
- 9. Программа должна содержать подпрограмму print\_array вывода на экран массива длины не более р. Эта подпрограмма используется для вывода исходного массива после его инициализации, а также для вывода на экран результирующего массива, если массив изменялся. Подпрограмма выводит на экран не более, чем р элементов массива, где р - параметр этой подпрограммы (аргумент командной строки). Каждый элемент массива должен печататься на новой строке.
- 10. Программа должна содержать функцию, получающую в качестве аргументов массив арт строк, целое число п, указатель на функцию стр сравнения ≤ элементов, и возвращающую количество элементов массива, строго меньших предыдущего элемента.
- 11. Вывод результата работы в функции таіп для задач 4-10 должен производиться по формату:

```
printf ("New array:\n");
print_array (a, n, p); /* вывод нового состояния массива a */
printf ("%s : Task = %d Diff = %d Elapsed = %.2f\n",
        argv[0], task, diff, t);
```
где

- argv[0] первый аргумент командной строки (имя образа программы),
- task номер задачи (1–10),
- diff возвращаемое значение функции, вычисляющей количество элементов массива, строго меньших предыдущего элемента, **после** работы функции, реализующей решение этой задачи,
- t время работы функции, реализующей решение этой задачи.
- 12. Вывод результата работы в функции main **для задачи 3** должен производиться по формату:

```
printf ("New array:\n");
print_array (a, n, p); /* вывод нового состояния массива a */
printf ("%s : Task = %d Res = %d Elapsed = %.2f\n",
        argv[0], task, res, t);
```
где argv[0], task, t – те же, что в предыдущем пункте, res – возвращаемое значение функции, реализующей решение этой задачи.

13. Вывод результата работы в функции main **для задачи 2** должен производиться по формату:

```
printf ("New array:\n");
print_array (с, n + m, p); /* вывод нового состояния массива c */
printf ("%s : Task = %d Diff = %d Elapsed = %.2f\n",
        argv[0], task, diff, t);
```
где argv[0], task, diff, t – те же, что в предыдущем пункте.

14. Вывод результата работы в функции main **для задачи 1** должен производиться по формату:

printf ("%s : Task = %d Res = %d Elapsed = %.2f\n", argv[0], task, res, t);

где argv[0], task, t – те же, что в предыдущем пункте, res – возвращаемое значение функции, реализующей решение этой задачи.

## **Задачи**

1. Написать функцию, получающую в качестве аргументов неубывающий массив *a*[*n*] строк, целое число *n*, являющееся длиной этого массива, строку *x*, указатель на функцию cmp сравнения элементов, и возвращающую место, где в этот массив можно вставить *x* (т.е. минимальное целое число *i* такое, что *x a*[*i*], если *x* больше всех элементов массива, то *i* = *n*). Место определяется двоичным поиском по следующему алгоритму (*алгоритм деления пополам*).

Взять первоначально 0 и *n* в качестве границ поиска элемента; далее, до тех пор, пока границы не совпадут, шаг за шагом сдвигать эти границы следующим образом: сравнить *x* с *a*[*s*], где *s* – целая часть среднего арифметического границ; если *a*[*s*] *x*, то заменить прежнюю нижнюю границу на *s* + 1, а верхнюю оставить без изменений, иначе оставить без изменения нижнюю границу, а верхнюю заменить на *s*; когда границы совпадут, став равными некоторому числу *t* , выполнение закончится с результатом *t* .

Общее количество сравнений и пересылок элементов в наихудшем случае не должно превышать 10g n + 0(1). Основная программа должна заполнять данными массив, выводить его на экран, вводить с командной строки х, вызывать эту функцию и выводить на экран результат ее работы.

2. Написать подпрограмму, получающую в качестве аргументов три массива a[n], b[m], c[n+m строк, где а[n], b[m] не убывают, целые числа п и т, указатель на функцию стр сравнения элементов, и строящую по неубывающим массивам а|п|, b|т| неубывающий массив с|л+т| слиянием первых двух за п+ т+ О(1) сравнений и п+ т+ О(1) пересылок элементов по следующему алгоритму

Просматриваем очередные элементы a[i], i = 0, ... ,n - 1 и b[j], j = 0, ... , m - 1 массивов а и b. Если a[i] ≤ b[j], то c[k] = a[i] и увеличиваем i на 1, иначе c[k] = b[j] и увеличиваем j на 1. Здесь k, k = 0, ... , n + m - 1 - очередной элемент массива с (здесь всегда равен i + j).

Основная программа должна заполнять данными массивы aln| и b|m|, выводить их на экран, вызывать эту подпрограмму и выводить на экран результат ее работы - массив с[и + m].

3. Написать функцию, получающую в качестве аргументов массив ап строк, целое число », являющееся длиной этого массива, строку х, указатель на функцию стр сравнения элементов, и переставляющую элементы массива так, чтобы вначале шли все элементы, меньшие х, а затем элементы, большие х. Функция возвращает место, где в этот массив можно вставить х (т.е. минимальное целое число і такое, что х < а и с больше всех элементов массива, то i = n). Решение задачи производится следующим алгоритмом:

Просматривая массив с начала (линейным поиском), находим і такое, что х ≤ а[]. Просматривая массив с конца (линейным поиском), находим ј такое, что а ј | < х. Если і < ј, то меняем a|| и a|j| местами, i увеличиваем на 1, j уменьшаем на 1. Повторяем эту процедуру пока i < j. После этого все элементы a[0] ... , a[i] будут не больше всех элементов a[j], ... , a[n - 1]. Возвращаемым значением функции будет i = j.

Общее количество сравнений элементов в наихудшем случае не должно превышать n + 0(1), а пересылок элементов - 3n/2+0(1). Основная программа должна заполнять данными массив, выводить его на экран, вводить с командной строки х, вызывать эту функцию и выводить на экран результат ее работы: массив а|п| и значение i = j.

4. Написать подпрограмму, получающую в качестве аргументов массив a/n/ строк , целое число п, указатель на функцию стр сравнения - элементов, и переставляющую элементы массива а[п] в неубывающем порядке: а|0| < a|1] < .·· < a|n - 1] по следующему алгоритму ("пузырьковая"сортировка):

Последовательным просмотром а[0],a[1], ... , a|n - 1] найти наименьшее і такое, что a|i+ 1] < a|i]. Поменять a|i| и a|i + 1] местами, возобновить просмотр с элемента a|i + 1] и тд. Тем самым наибольший элемент передвинется на последнее место. Следующие просмотры начинать опять сначала, уменьшая на 1 количество просматриваемых элементов. Массив будет упорядочен после просмотра, в котором участвовали только первый и второй элементы.

Общее количество сравнений в наихудшем случае не должно превышать nº /2 + O(n), а пересылок элементов - 3n2/2+0(n). Основная программа должна заполнять данными массив, выводить его на экран, вызывать эту подпрограмму и выводить на экран результат ее работы. 5. Написать подпрограмму, получающую в качестве аргументов массив а/п/ строк , целое число п, указатель на функцию стр сравнения ≤ элементов, и переставляющую элементы массива а[п] в неубывающем порядке: а|0| < a|1] < .·· < a|n - 1] по следующему алгоритму (сортировка нахождением минимума):

Найти элемент массива, имеющий наименьшее значение, переставить его с первым элементом, затем проделать то же самое, начав со второго элемента и т.д.

Общее количество сравнений в наихудшем случае не должно превышать и2 / 2 + О(и), а пересылок элементов - 3n + 0(1). Основная программа должна заполнять данными массив, выводить его на экран, вызывать эту подпрограмму и выводить на экран результат ее работы.

6. Написать подпрограмму, получающую в качестве аргументов массив а/п/ строк , целое число п, указатель на функцию стр сравнения < элементов, и переставляющую элементы массива а[г] в неубывающем порядке: a[0] ≤ a[1] ≤ ··· ≤ a[n - 1] по следующему алгоритму (сортировка линейной вставкой):

Просматривать последовательно а[1], ... , a|n - 1] и каждый новый элемент a|i| вставлять на подходящее место в уже упорядоченную совокупность а[0] ... , a] - 1]. Это место определяется последовательным сравнением а| с упорядоченными элементами а|0], ... , a|i - 1].

Общее количество сравнений и пересылок элементов в наихудшем случае не должно превышать n2/2 + O(n) (каждое). Основная программа должна заполнять данными массив, выводить его на экран, вызывать эту подпрограмму и выводить на экран результат ее работы.

7. Написать подпрограмму, получающую в качестве аргументов массив али строк , целое число п, указатель на функцию стр сравнения < элементов, и переставляющую элементы массива а[п] в неубывающем порядке: a[0] ≤ a[1] ≤ ··· ≤ a[n - 1] по следующему алгоритму (сортировка двоичной вставкой):

Просматривать последовательно а[1], ... , a|n - 1] и каждый новый элемент a|i| вставлять на подходящее место в уже упорядоченную совокупность а[0] ... , a]i - 1]. Это место определяется алгоритмом деления пополам (см. задачу 1).

Общее количество сравнений в наихудшем случае не должно превышать л logo n + 0(n), a пересылок элементов – n2 /2 + 0(n). Основная программа должна заполнять данными массив, выводить его на экран, вызывать эту подпрограмму и выводить на экран результат ее работы.

8. Написать подпрограмму, получающую в качестве аргументов массив а/гі строк и вспомогательный массив b b c строк,, целое число n, указатель на функцию стр сравнения > элементов, и переставляющую элементы массива арп в неубывающем порядке: a(0) ≤ a[1] ≤ ··· ≤ а п - 1 по следующему алгоритму (сортировка Неймана):

Вначале весь массив рассматривается как совокупность упорядоченных групп по одному элементу в каждом. Слиянием соседних групп (см. задачу 2) получаются упорядоченные группы, каждая из которых содержит два элемента (кроме, может быть, последней группы, которой не нашлось парной). Далее упорядоченные группы укрупняются тем же способом и т.д. Используется вспомогательный массив b[n].

Общее количество сравнений и пересылок элементов в наихудшем случае не должно превышать под-п + 0(n) (каждое). Основная программа должна заполнять данными массив, выводить его на экран, вызывать эту подпрограмму и выводить на экран результат ее работы.

9. Написать подпрограмму, получающую в качестве аргументов массив а/п/ строк , целое число п, указатель на функцию стр сравнения ≤ элементов, и переставляющую элементы массива а[п] в неубывающем порядке: a|0| ≤ a|1| ≤ ··· ≤ a|n - 1| по следующему алгоритму ("быстрая"сортировка):

Полагаем x = a|n/2|. Алгоритмом задачи 3 находим место, где в этот массив можно вставить х, т.е. такое і, что все элементы а|0], ... ,a|i - 1] будут меньше или равны всех элементов ар ... , а|п - 1 . Затем сортируем каждую из частей (т.е. а|0), ... , а|i - 1] и - 1]) этим же алгоритмом. Для уменьшения глубины рекурсии вначале сортируем более короткий массив. Затем вместо повторного вызова процедуры переходим к ее началу с новыми значениями указателя на начало массива а и его длины п.

Общее количество сравнений в наихудшем случае не должно превышать nº /2 + O(n), а пересылок элементов - 3n2/2+0(n). Основная программа должна заполнять данными массив, выводить его на экран, вызывать эту подпрограмму и выводить на экран результат ее работы.

10. Написать подпрограмму, получающую в качестве аргументов массив а/и) строк , целое число п, указатель на функцию стр сравнения - элементов, и переставляющую элементы массива а[п] в неубывающем порядке: а|0| ≤ a|1| ≤ ··· ≤ a|n - 1| по следующему алгоритму ("турнирная"сортировка или алгоритм heapsort):

Массив а|п| рассматриваем как бинарное дерево с корнем а|0). Для элемента с номером a k потомками являются элементы a 2 \* k + 1 и a 2 \* k + 2], a родителем - элемент a ( k -1)/2]. На первом этапе алгоритма превращаем наше бинарное дерево в т.н. упорядоченную пирамиду, т.е. в дерево, в котором всякая цепочка от корня до любого конечного элемента выстроена по убыванию. Для этого для всех k = 1 ... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . его родителей, продвигая его на свое место (подобно тому, как это делалось в алгоритме сортировки линейной вставкой). После этого этапа алгоритма в корне дерева (т.е. в а(0)) будет находиться максимальный элемент массива. На втором этапе алгоритма для всех k = n - 1, ... , 1: меняем корень (т.е. a|0) и элемент a|k| местами и рассматриваем массив а как имеющий длину к. В этом массиве восстанавливаем структуру упорядоченной пирамиды, нарушенную помещением элемента a/k] в a(0). Для этого идем от элемента a(0) по цепочкам его потомков, продвигая его на свое место (подобно тому, как это делалось в алгоритме сортировки линейной вставкой, с одним отличием: элемент пирамиды должен быть больше обоих своих потомков).

Общее количество сравнений в наихудшем случае не должно превышать 4nlogon + 0(n), а пересылок элементов - 2nlogon +0(n). Основная программа должна заполнять данными массив, выводить его на экран, вызывать эту подпрограмму и выводить на экран результат ее работы.