## Требования к программам

- 1. Программа должна получать все параметры в качестве аргументов командной строки.
- 2. Во всех задачах требуется вычислить вектор, являющийся т-м элементом указанной в условии последовательности, строящейся по заданной и × n матрице A и 0-му элементу последовательности хо.
- 3. Аргументы командной строки для задач 1, 3-6:
	- 1) m номер элемента последовательности,
	- 2) n число строк и столбцов n x n матрицы A,
	- 3) р количество выводимых значений в матрице и векторах,
	- 4) kg задает номер формулы для инициализации матрицы A, должен быть равен 0 при вводе матрицы А из файла,
	- 5) fA имя файла, откуда надо прочитать матрицу А. Этот аргумент отсутствует, если kA! = 0,
	- 6) kx задает номер формулы для инициализации вектора хо размера n x 1, должен быть равен 0 при вводе вектора хо из файла,
	- 7) fx имя файла, откуда надо прочитать вектор хо. Этот аргумент отсутствует, если kx! = 0.

Например, запуск

./a.out 100 6 5 0 a.txt 0 x.txt

означает, что матрицу А 6 × 6 надо прочитать из файла а . txt, вектор хо длины 6 надо прочитать из файла х . txt, выводить не более 5 строк и столбцов матрицы и вектора, вычислить требуется 100-й элемент последовательности х100; а запуск

./a.out 100 2000 6 1 4

означает, что матрицу А 2000 х 2000 надо инициализировать по формуле номер 1, вектор хо длины 2000 надо инициализировать по формуле номер 4 (как матрицу 2000 × 1), и выводить не более 6-ти строк и столбцов матрицы и вектора, вычислить требуется 100-й элемент последовательности х100 ·

- 4. Аргументы командной строки для задач 2, 7-10:
	- 1) т параметр т подпрограммы,
	- 2) m номер элемента последовательности,
	- 3) n число строк и столбцов n × n матрицы A,
	- 4) р количество выводимых значений в матрице и векторах,
	- 5) kg задает номер формулы для инициализации матрицы А, должен быть равен 0 при вводе матрицы А из файла,
	- 6) fa имя файла, откуда надо прочитать матрицу А. Этот аргумент отсутствует, если kA! = 0,
- 7) kx задает номер формулы для инициализации вектора хо размера n × 1, должен быть равен 0 при вводе вектора хо из файла,
- 8) fx имя файла, откуда надо прочитать вектор хо. Этот аргумент отсутствует, если kx! = 0.
- 5. Ввод матрицы должен быть оформлен в виде подпрограммы, находящейся в отдельном файле.
- 6. Ввод матрицы из файла. В указанном файле находится матрица в формате:

$$\begin{array}{cccc} a\_{1,1} & \cdots & a\_{1,n} \\ a\_{2,1} & \cdots & a\_{2,n} \\ \cdots & \cdots & \cdots & \cdots \\ a\_{m,1} & \cdots & a\_{m,n} \end{array}$$

где m × n - указанные размеры матрицы, A = (a; ;) - матрица. Программа должна выводить сообщение об ошибке, если указанный файл не может быть прочитан, содержит меньшее количество данных или данные неверного формата.

7. Ввод матрицы и правой части по формуле. Элемент ад ; матрицы А размера т × n полагается равным

$$a\_{i,j} = f(k, m, n, i, j), \quad i = 1, \ldots, m, \quad j = 1, \ldots, n, \quad i$$

где f(k,m,n,i,j) - функция, которая возвращает значение (i,j)-го элемента т × n матрицы по формуле номер к (аргумент командной строки). Функция ƒ(k,m,n,i,j) должна быть оформлена в виде отдельной подпрограммы.

$$f(k,m,n,i,j) = \begin{cases} \max\{n,m\} - \max\{i,j\} + 1 & \text{npm} \quad k=1\\ \max\{i,j\} & \text{npm} \quad k=2\\ |i-j| & \text{npm} \quad k=3\\ \hline 1 & \text{npm} \quad k=4 \end{cases}$$

8. В задачах 2-10, где участвует вектор b, он строится после инициализации матрицы A = (ai,j)i,j=1,....n по формуле:

$$b = (b\_i)\_{i=1,\dots,n}, \quad b\_i = \sum\_{k=0}^{(n-1)/2} a\_{i,2k+1}$$

Инициализация должна быть оформлена в виде подпрограммы, вызываемой из функции main.

- 9. Решение должно быть оформлено в виде подпрограммы, находящейся в отдельном файле.
- 10. Программа должна содержать подпрограмму вывода на экран прямоугольной матрицы и х п матрицы. Эта подпрограмма используется для вывода исходной m x n матрицы после ее инициализации, а также для вывода на экран результата работы программы. Подпрограмма выводит на экран не более, чем р строк и столбцов m x n матрицы, где р - параметр этой подпрограммы (аргумент командной строки). Каждая строка матрицы должна печататься на новой строке, каждый элемент матрицы выводится в строке по формату " 310. Зе" (один пробел между элементами и экспоненциальный формат 810.3e).
- 11. Функция, реализующая задачу, не должна выделять или использовать дополнительную память.
- 12. Сложность работы подпрограммы не должна превышать С(m+1) \*n2 при и → ∞, m →∞. Константа С = 1 в задачах 1-7, С = 3/2 в задачах 8, 9, С = 2 в задаче 10. Это означает, что при переходе от Xk-1 к Xk
	- может быть только одно умножение матрицы А на вектор (во всех задачах),
	- надо решать систему линейных уравнений с треугольной матрицей методом последовательного исключения неизвестных (в задачах 8-10).
- 13. Результатами работы задач 1-10 являются 3 элемента:
	- Собственно вектор Xm •
	- Два вещественных числа 1 и 12, вычисляемых после вызова задачи:
		- Для задачи 1

r1 = возвращаемое значение функции, r2 = =

- Для задач 2-10

$$r\_1 = \sum\_{i=1}^n \left| \left( \sum\_{j=1}^n a\_{ij} x\_j \right) - b\_i \right| \Big/ \sum\_{i=1}^n |b\_i|, \quad r\_2 = \sum\_{i=1}^n |x\_i - (i \bmod 2)| \Big/ \sum\_{i=1}^n (i \bmod 2)|$$

Здесь (xi)i=1.....n - это компоненты вектора xm.

Вычисление r1 и r2 должно быть оформлено в виде подпрограммы, вызываемой из функции main. Эта подпрограмма не должна выделять или использовать дополнительную память.

## 14. Вывод результата работы функции в функции main должен производиться по формату:

- Непосредственно вывод вектора xm. Он выводится вызовом подпрограммы печати матрицы (см. пункт 10) размера 1 x n (т.е. в строку и по указанному там формату)
- Отчет о результате и времени работы:

$$\begin{array}{rcl} \mathtt{print} & \mathtt{"\\$s \text{ : } \mathtt{Task} = \mathtt{\\$d \text{ } Res1 = \{\mathtt{e \\$es2} = \{\mathtt{e \\$Elapsed} = \mathtt{\\$s \text{ } 2f/n\text{ }\}\}} \\ & \mathtt{array} \{\mathtt{0}\}, \ \mathtt{task}, \ \mathtt{r1}, \ \mathtt{r2}, \ \mathtt{t}\}; \end{array}$$

где

- argv [ 0 ] первый аргумент командной строки (имя образа программы),
- task номер задачи (1-10),
- r1 = r1 вычисленное значение r1 (см. пункт 13),
- r2 = r2 вычисленное значение r2 (см. пункт 13),
- t время работы функции, реализующей решение этой задачи.

Вывод должен производиться в точности в таком формате, чтобы можно было автоматизировать обработку запуска многих тестов.

## **Задачи**

- 1. Написать функцию, получающую в качестве аргументов *n* × *n* матрицу *A*, вектора *x*<sup>0</sup> , *x*, целые числа *n* и *m*, и возвращающую *m*-й член последовательности {λ*k*}, где λ*<sup>k</sup>* = (*Ax<sup>k</sup>* , *x<sup>k</sup>* )/(*x<sup>k</sup>* , *x<sup>k</sup>* ), *x<sup>k</sup>* = *Axk*−<sup>1</sup> , *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой, (·,·) — евклидово скалярное произведение. В векторе *x* возвращается значение *x<sup>m</sup>* .
- 2. Написать подпрограмму, получающую в качестве аргументов *n* × *n* матрицу *A*, вектора *x*<sup>0</sup> , *b*, *x*, целые числа *n*, *m* и вещественное число τ , и возвращающую в векторе *x m*-й член последовательности {*xk*}, где (*xk*−*xk*−<sup>1</sup> )/τ +*Axk*−<sup>1</sup> = *b*. *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой.
- 3. Написать подпрограмму, получающую в качестве аргументов *n* × *n* матрицу *A*, вектора *x*<sup>0</sup> , *b*, *x*, *r* целые числа *n* и *m*, и возвращающую в векторе *x m*-й член последовательности {*xk*}, где (*x<sup>k</sup>* − *xk*−<sup>1</sup> )/τ*k*−<sup>1</sup> + *Axk*−<sup>1</sup> = *b*, τ*<sup>k</sup>* = (*r<sup>k</sup>* ,*rk* )/(*Ar<sup>k</sup>* ,*rk* ), *r<sup>k</sup>* = *Ax<sup>k</sup>* − *b*, (·,·) — евклидово скалярное произведение. *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой, *r* – дополнительная память.
- 4. Написать подпрограмму, получающую в качестве аргументов *n* × *n* матрицу *A*, вектора *x*<sup>0</sup> , *b*, *x*, *r*, целые числа *n* и *m*, и возвращающую в векторе *x m*-й член последовательности {*xk*}, где (*x<sup>k</sup>* −*xk*−<sup>1</sup> )/τ*k*−<sup>1</sup> +*Axk*−<sup>1</sup> = *b*, τ*<sup>k</sup>* = (*Ar<sup>k</sup>* ,*rk* )/(*Ar<sup>k</sup>* ,*Ar<sup>k</sup>* ), *r<sup>k</sup>* = *Ax<sup>k</sup>* −*b*, (·,·) — евклидово скалярное произведение. *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой, *r* – дополнительная память.
- 5. Написать подпрограмму, получающую в качестве аргументов *n*×*n* матрицу *A*, вектора *x*<sup>0</sup> , *b*, *x*, *r* целые числа *n* и *m*, и возвращающую в векторе *x m*-й член последовательности {*xk*}, где *D*(*x<sup>k</sup>* −*xk*−<sup>1</sup> )/τ*k*−<sup>1</sup> +*Axk*−<sup>1</sup> = *b*, τ*<sup>k</sup>* = (*D* −1 *rk* ,*rk* )/(*AD*−<sup>1</sup> *rk* ,*D* −1 *rk* ), *r<sup>k</sup>* = *Ax<sup>k</sup>* −*b*, *D* — диагональ матрицы *A*, (·,·) — евклидово скалярное произведение. *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой, *r* – дополнительная память.
- 6. Написать подпрограмму, получающую в качестве аргументов *n* × *n* матрицу *A*, вектора *x*<sup>0</sup> , *b*, *x*, *r*, целые числа *n* и *m*, и возвращающую в векторе *x m*-й член последовательности {*xk*}, где *D*(*x<sup>k</sup>* −*xk*−<sup>1</sup> )/τ*k*−<sup>1</sup> +*Axk*−<sup>1</sup> = *b*, τ*<sup>k</sup>* = (*AD*−<sup>1</sup> *rk* ,*rk* )/(*AD*−<sup>1</sup> *rk* ,*AD*−<sup>1</sup> *rk* ), *r<sup>k</sup>* = *Ax<sup>k</sup>* −*b*, *D* — диагональ матрицы *A*, (·,·) — евклидово скалярное произведение. *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой, *r* – дополнительная память.
- 7. Написать подпрограмму, получающую в качестве аргументов *n* × *n* матрицу *A*, вектора *x*<sup>0</sup> , *b*, *x*, *r*, целые числа *n*, *m* и вещественное число τ , и возвращающую в векторе *x m*-й член последовательности {*xk*}, где *D*(*x<sup>k</sup>* − *xk*−<sup>1</sup> )/τ + *Axk*−<sup>1</sup> = *b*, *D* — диагональ матрицы *A*. *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой, *r* – дополнительная память.
- 8. Написать подпрограмму, получающую в качестве аргументов *n*×*n* матрицу *A*, вектора *x*<sup>0</sup> , *b*, *x*, *r*, *w*, целые числа *n*, *m* и вещественное число τ , и возвращающую в векторе *x m*-й член последовательности {*xk*}, где (*D* + *L*)(*x<sup>k</sup>* − *xk*−<sup>1</sup> )/τ + *Axk*−<sup>1</sup> = *b*, *D* — диагональ матрицы *A*, *L* — нижняя треугольная часть матрицы матрицы *A*. *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой, *r*, *w* – дополнительная память.
- 9. Написать подпрограмму, получающую в качестве аргументов *n*×*n* матрицу *A*, вектора *x*<sup>0</sup> , *b*, *x*, *r*, *w*, целые числа *n*, *m* и вещественное число τ , и возвращающую в векторе *x m*-й член последовательности {*xk*}, где (*D* + *R*)(*x<sup>k</sup>* − *xk*−<sup>1</sup> )/τ + *Axk*−<sup>1</sup> = *b*, *D* — диагональ матрицы *A*,

*R* — верхняя треугольная часть матрицы матрицы *A*. *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой, *r*, *w* – дополнительная память.

10. Написать подпрограмму, получающую в качестве аргументов *n*×*n* матрицу *A*, вектора *x*<sup>0</sup> , *b*, *x*, *r*, *w*, целые числа *n*, *m* и вещественное число τ , и возвращающую в векторе *x m*-й член последовательности {*xk*}, где (*D* + *L*)*D* −1 (*D* + *R*)(*x<sup>k</sup>* − *xk*−<sup>1</sup> )/τ + *Axk*−<sup>1</sup> = *b*, *D* — диагональ матрицы *A*, *L* — нижняя треугольная часть матрицы матрицы *A*, *R* — верхняя треугольная часть матрицы матрицы *A*. *x*<sup>0</sup> – 0-й элемент последовательности, значение которого может меняться подпрограммой, *r*, *w* – дополнительная память.